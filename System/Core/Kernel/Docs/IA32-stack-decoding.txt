Copyright (c) 2000-2007 Андрей Валяев (dron@infosec.ru)
All rights reserved.

Создано: 18/06/07 22:30:51

В данном доке описаны методы корректного извлечения полезных данных из стека
при отображении синего экрана смерти.

Извлечение адреса функции

Метод 1 - direct call

В стеке обнаруживается адрес возврата (адрес, попадающий в пространство кода
ядра). От этого адреса отсчитывается 5 байт назад. По указанному адресу должен
обнаружится call с непосредственным операндом. Прибавив значение
непосредственного операнда к адресу возврата получаем адрес вызванной функции.

Метод 2 - обратное сканирование.

Поскольку косвенный call не может послужить источником адреса, но зато он может
послужить явным признаком того, что значение стека точно является адресом
возврата. (ну это так, к слову) К сожалению под этот пункт попадут все
виртуальные методы.

В отсутствии прямого call единственный способ, который остается - это от
текущего указателя сканировать символы назад до начала функции. (Отслеживание
начала функции - позже)

В самом простом варианте - это отображение смещения от ближайшей метки.
[GrindarsOS]


Определение начала функции и количества локальных переменных

Метод 1 - stack frame.

В данном случае функции обычно начинаются с команд
	push ebp
	mov ebp, esp
Возможен вариант с применением еnter, но на практике это почти не встречается.
Иногда, в конечых функциях, использование ebp не требуется. И вышеуказанный код
опускается.

Факт наличия и количество локальных переменных можно определить по наличию
следующей инструкции
	sub	esp, imm

imm / 8 - показывает количество локальных переменных (слов стека)
Которое в свою очередь косвенно может определять количество аргументов
очередного вызова.


Получение количества аргументов функции.

Метод 1 - cdecl

Если инструкция по адресу возврата содержит команду add esp, imm - то это прямо
указывает на наличие аргументов. imm необходимо поделить на 4, и
соответствующее количество стековых слов смело относить к аргументам функции.

Метод 2 - stdcall

Если первый метод не сработал, то от начала функции (см Извлечение адреса
функуии) нужно провести поиск инструкции retn imm. в случае обнаружения таковой
значение imm явно показывает количество аргументов.

Но стоит быть внимательным, обнаружение команды retn является признаком
неприменимости данного метода и кроме того возможны ложные срабатывания.

Метод 3 - push count

От адреса возврата отходим назад, пропустив команду call, и начинаем считать
непосредственно идущие push. Их количество должно быть сопоставимо с
результатами метода 1 или 2. Но возможны расхождения в следствии оптимизации
или в следствии чередования команд push c другими.

Метод 4 - оставшиеся слова стека

После разворота функции верхнего уровня оставшееся незадействованными слова
стека могут быть причислены к аргументам функции.

Метод 5 - декорированные имена С++

В декорированном имени C++ содержится информафия об аргументах функции.
Этим можно воспользоваться.

Иначе.

В противном случае определение количества аргументов практически не возможно.
Никто не станет внедрять в БСоД полный дизассемблер или эмулятр. Кстати
дизассемблер было бы не плохо, хотя бы на основные мнемоники.

Для большей уверенности лучше всего совмещать несколько методов определения.

А символы - их можно передать через GRUB, правда для этого придется загружать
нестрипанное ядро, но это не большая проблема.
