\section{Переносимое ядро}

Универсальное ядро написано на C++, и реализует по большому счету объектный
движок ресурсов. Но пока это только неструктурированный особо набор мыслей.

\subsection{Ресурсы}

\subsubsection{Идентификаторы ресурсов}

Каждый ресурс имеет уникальный идентификатор.

Создание идентификаторов можно было бы реализовать просто инкрементом. Но при
активном использовании ресурсов 32-х битное значение идентификатора переполнится
за несколько дней. Дальнейшее создание идентификаторов невозможно без
сопоставления со списком имеющихся ресурсов.

Поэтому, идентификаторы всегда будут генерироваться случайным образом, с
последующим сопоставлением со списком ресурсов. Общее количество ресурсов,
одновременно существующих в ядре, вряд ли привысит несколько милионов, так что
процент попаданий будет невелик. Этот алгоритм не обладает большой скоростью, но
он гарантированно дает уникальные идентификаторы не зависимо от
продолжительности работы системы.

\subsubsection{Инстанции ресурсов}

Думаю что стоит ограничить доступ к ресурсам исключительно через инстанции
\footnote{Не совсем понимаю, что хотел этим сказать. У меня и так весь доступ к
ресурсам, за исключением глобальных ресурсов, осуществляется через инстанции.
Это вот страницы у меня могли быть доступны напрямую, типа память на одной
инстанции экономил. Хех, отказавшись от этого я в два раза сократил само
PageInfo.}.

Ресурсы, доступные глобально, тоже декларируют для этого инстанцию. Глобальные
инстанции будут храниться в списке глобальных инстанций.

Поиск ресурса производится через доступные инстанции, при этом в поисках
инстанции проверяется список процесса и список глобальных инстанций. Список
ресурсов с целью поиска нужного ресурса не просматривается.

\subsection{Регионы}

Регионы - одно из ключевых упущений предыдущего ядра. До последнего момента я не
уделял им должного внимания и в результате необходимый функционал набазе того
ядра просто не может быть теперь реализован.

Регион - один из ключевых ресурсов ядра. Регион является хранилищем страниц
ограниченного диапазона линейной памяти. Размер региона задается в байтах
\footnote{Причем размер региона не обязан быть кратен размеру страницы.}. Для
точного позиционирования в регионе относительно страниц используется смещение
\footnote{Величина смещения не должна превышать размер страницы.}.

Регионы могут наследовать области памяти от других регионов. Причем размеры и
смещение дочернего региона не обязано соответствовать размеру и смещению
родительского. Дочерний регион может быть меньше, хотя страничного расположения
нарушать нельзя. Регионы могут быть сассоциированы так же с областью физической
памяти.

Несколько вырожденный случай, регионы могут быть сассоциированы с диапазоном
портов ввода-вывода, при этом смысл размера и смещения несколько меняется в
направлении полной таблицы портов ввода-вывода.

Для привязки регионов к процессам\footnote{Только процессы у нас могут владеть
ресурсами} используются регионные инстанции, которые могут содержать в себе
линейный адрес размещения региона. У различных процессов привязка региона может
варьироваться.

В случае необходимости ядро может привязывать регион нга определенный адрес, но
основным способом является выбор адреса привязки на усмотрение ядра. А ядро в
этом плане будет весьма непредсказуемо, что позволит повысить надежность системы.

\subsection{Неотсортированное}

Нити связываются в списки планирования по полю состояния. причем нить всегда
находится в одном из списков планирования, которых будет три. активные, iddle,
sleep.

Хотя я еще не решил насчет трех списков. список спящих однозначно будет
отдельным (последним) А активных списков возможно будет три - high, normal, iddle

Список ожидающих нитей в ресурсе будет. Причем он будет иметь характер
дополнительного. если нить ожидает завершения ресурса - она всеравно имеет
определенный интервал сна который может быть прерван.

\subsection{Вспомогательные возможности}

\subsubsection{Генерация псевдослучайных чисел}

Для генерации ПСЧ необходим алгоритм, от которого будет зависеть
работоспособность ядра, так что он не должен сходиться\footnote{Если значения
будут повторяться, то это грозит полным зависанием ядра, ядро не сможет выбрать идентификатор.}. На счет энтропии пока не знаю, но ГПСЧ выберу понадежнее -
"Вихрь мерсенна".

\subsubsection{Форматный вывод}

На основе функции StubPrintChar Переносимое ядро реализует функцию CorePrint,
которая обладает следующими возможностями форматирования: Знак '\%' используется
как символ служебного префикса в строке формата. Для того, чтобы вывести знак
'\%' в поток - Этот символ пишется дважды - '\%\%'. [<width>][l](x|u|b|s) После
префикса для целочисленных значений может быть указана ширина числа. Стоит
отметить, что это именно количество значащих цифр числа, дополнение пробелами
не поддерживается. После ширины может быть указана размерность 'l' которая
показывает, что число имеет размер - двойное слово\footnote{Обычным словом я
буду называть не 16 бит, как принято, а типичный для платформы размер.}.

Вывод строки не подразумевает указания ширины и размера. Вывод бинарных величин
не предполагает указания ширины, но возможно указание размера. При этом значение
числа не превышает $10 * 1024$, большее число делится до двоичных единиц - KiB,
MiB, GiB.

Шестнадцатиричные 'x' и десятичные 'u' могут быть выведены с применением ширины,
но если ширина меньше чем значение числа - число всеравно будет выведено
полностью.

Знаковые числа не поддерживаются.
