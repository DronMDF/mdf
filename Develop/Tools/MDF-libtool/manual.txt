0. MDF-libtool

Набор инструментов для сборки/тестирования библиотек.


1. lt_includegen

Преобразует файл шаблона в предварительный вариант инклюд файла.

Файл шаблона в принципе ничем особо не отличается от обычного инклюда,
служебных моментов всего два.

1.1. #pragma once

Компилятор на него жестого ругается, будем замещать традиционными сишными
скобками. #ifndef/#define/#endif

Ради удобства введем дополнительный параметр, Собственно имя переменной.

Кроме того сама прагма может находиться в любом месте текста, но скобки будут
подставлены конкретно в начало и конец файла. #ifndef/#define будет вставлен
вместо #pragma, при условии что до него нет ничего кроме комментариев, в
противном случае надо выдать ошибку. Не надо забывать про перевод строки после
#endif, это может вызватть варнинг.

	--- include.h.in
	// пример
	#pragma once(__TEST_H__)

	<Всякая байда>
	--- include.h.out
	// пример
	#ifndef __TEST_H__
	#define __TEST_H__

	<Всякая байда>

	#endif //__TEST_H__
	---

Если имя переменной не указано - будет сгенерировано автоматичски.

1.2. #pragma prototypes

Эта прагма естествено не поддерживается компилятором, в процессе обработки
будет замещена на конструкцию вида extern "C" { ... }, вместо троеточия в
процессе дальнейшего парсинга будут подставлены прототипы функций.

	--- include.h.in
	#pragma prototypes
	--- include.h.out
	extern "C" {
	}
	---


2. lt_unitgen

Утилита делит исходные xml файлы на модули и тесты для них.
Эта же утилита прописывает прототипы в инклюды. И генерирует мейкфайл для
библиотеки, имя которой указывается в командной строке.

В полученном мейкфайле можно будет легко разрулить все тестирования и все
зависимости.

В процессе работы утилиты на выходе получается
	- Файл юнита
	- Файлы тестов (на каждый тест по файлу)
	- Мейкфайл (опционально)

Прототипы функций могут быть опубликованы в файле инклюда. (опционально)
Мейкфайл может быть опубликован в общем мейкфайле. (опционально)

2.1. Опци командной строки



2.2. Формат xml файлов

<?xml version="1.0" encoding="utf-8"?>
<MDF-libtool-unit>
	<unit name="strcpy">
		<prototype type="char *" declsin="string.h">
			<arg order="1" type="char *" name="s1"/>
			<arg order="2" type="const char *" name="s2"/>
		</prototype>
		<body>
			<depend name="strncpy" declsin="string.h"/>
			return strncpy (s1, s2, 0xffffffff);
		</body>
		<test name="main">
			<depend name="memcmp" declsin="string.h"/>
			char dst[8];

			TSTEP (UNIT (dst, "abcdef") == dst);
			TSTEP (memcmp(dst, "abcdef", 7) == 0);

			UNIT (dst, "ghi");
			TSTEP (memcmp(dst, "ghi\0ef", 7) == 0);

			UNIT (dst, "");
			TSTEP (memcmp(dst, "\0hi\0ef", 7) == 0);
		</test>
		<man>
			Руководство по использованию функции.
			Если понадобиться его сгенерировать.
			Возможно прямо здесь будет инструкция на всех языках.
		</man>
	</unit>
</MDF-libtool-unit>

Тестовых функций может быть несколько.

Для тестовых функций можно будет реплейсить внешние функции для более
конкретного тестирования...

<unit name="malloc">
	...
	<test>
		<replace name="KernelCreateRegion">
			Здесь альтернативная реализация KernelCreateRegion.
		</replace>
		...
	</test>
	...
</unit>

999. Устаревшее.

Набор средств, предназначенных для сборки библиотек с тестированием отдельных
модулей.

Предположительно будет работать путем создания временного Makefile во временной
директории. Кроме того из исходных файлов будут генерироваться исходные тексты
рабочих и тестовых модулей.

Настройка производится путей внесения в исходный код служебных тегов.
Которые обрамляются квадратными скобками.

	---
	[ Информация для парсера ]

	<собственно функция>
	---

Парсер рассматривает функции отдельно друг от друа. у каждой функции желателен
тег парсера.

Функции бывают трех видов.

	1. Рабочие функции

Тег парсера [ unit .... ]

Опци

	---
	[	unit
		prototype in string.h;
		depend memcmp;
	]

	int strcmp (char *a, char *b)
	{
		return 0;
	}
	---


	2. Тестовые функции

Тестовые функции обязаны возвращать статус код.
Код TEST_SUCCESS говорит об успешном завершении.

Тег парсера [ test ... ]

Опци:
	unit <название функции>	- Указать на функцию, которую собственно
тестируем.

	---
	[	test
		unit strcmp;
	]

	TRESULT test_strcmp (void)
	{
		return TRESULT_SUCCESS;
	}
	--


	3. Заместители рабочих функций.

Прототип функции должен соответстватть обычной, но содержимое может бытть
полностью изменено, и может содержать тестовые выражения.

Тег парсера [ replacer ... ]

Опции:
	test <имя тестируемой фу $(MDF_IMAGE)/Develop/Libray/libUnicode.laнкции> - указывает к какому тестовому модулю
подключается данная функция.

	---
	[	replacer
		test strcmp;
	]

	int memcmp()
	{
		return 0;
	}
	---


	Тестовые выражения

Тестирование модулей осуществляется тестовыми функциями, в которых,
наравне я языковыми конструкциями, допустимо использование тестовых выражений

	TSEQUENCE_EQ(выражение, выражение)
проверяется код возврата функции. В случае совпадения тест считается пройденным.

	TSEQUENCE_MEQ(выражение, шаблон[, длина])
Сравнить содержимое указателя с шаблоном.


	Утилиты

lt_include

На основе файла .h.in генерирует .h файл. Протоитпы функций вставляются туда
позже. на этапе компиляции модулей.

lt_compile

На основе сишного файла с тегами создает набор объектных файлов, для
каждой функции или переменной - свой, тестовый модуль - для каждой функции
свой, если есь конечно. объектные файлы сразу добавляются библиотеку. указанную
в опциях. Прототипы функций вставляются в соответствующие инклюд-файлы.

lt_test

Производит тестирование модулей на основе тестовых файлов. С учетом указанных
в тестовых же файлах зависимостей.
