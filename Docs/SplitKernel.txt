Этот документ носит стутус идеи. Которая мне нравится. Но возможно я чего-то не
учел?

Андрей Валяев (dron@infosec.ru)

РАЗДЕЛЕННОЕ ЯДРО

Вступление.

Я давно думал на тему - как дать приложению максимальный объем памяти -
собственно 4 гига. Но прежние домыслы натыкались на различные препятситвия,
которые я сперва не учитывал, А потом они становились фатальными.

Короче нынешняя идея - мне кажется вполне осуществимой. Но все по порядку.


Основная структура ядра.

Для экономии пространства приложений, а так же для увеличения свободы ядра -
оно делится на две части.

Первая часть - Легкое ядро. Входит в линейное пространство приложений но
занимает сравнительно не много места. Я думаю если выделить один каталог
страниц для этих целей - будет нормально. Легкое ядро не перегружено кодом.
Всмысле его там почти совсем нету. В Легком ядре содержатся GDT и IDT.

Все гейты из IDT упираются в легковесные обработчики, которые действуют тупо и
прямолинейно (я думаю они будут состоять из считанных команд ассемблера).

GDT Описывает сегменты для легкого ядра, для тяжелого ядра и для приложений.
Так же в GDT описаны шлюзы задач тяжелого ядра. А так же набор
дескрипторов текущих активных задач.

Кроме этого легковесное ядро содержит сегменты состояния текущих активных задач.

Вторая часть - это насыщенное сложными алгоритмами тяжелое многозадачное
(несколько контекстов выполнения) ядро.


Тяжелое ядро.

Каждая нить системы снабжается контекстной страницей. В которой хранится ее
TSS, и ее состояние. Возможно использование одной страницы для нескольних
контекстов.

Тяжелое ядро работает с интервалом, который я временно назвал тяжелым квантом.
Тяжелый квант это весьма продолжительный период времени, думаю до 100мс.
Планировщик тяжелого ядра выбирает из очереди некоторое количество активных
задач. Контексты задач мапятся в легкое ядро, в GDT создаются селекторы для
текущих активных задач. И определяется порядок их выполнения.

При наличии нескольких процессоров - для каждого аппаратного ядра используется
свое легкое ядро. И для каждого отбирается свой список задач. При отборе можно
учитывать принадлежность к процессам, и другие оптимизирующие факторы.

В случае небольшого количества активных процессов - возможно манипулирование
размерами легкого кванта. В принципе манипулирование возможно всегда.

После этого управление передается легким ядрам, которые, тупо выполняют все
указанные для них задачи.


Легкое ядро

Легкие ядра, как уже говорил - не отягощены сложной логикой.

В случае исключений легкое ядро останавлиает задачу и сохраняет информацию
о произошедшем исключении.

Прерывания от аппаратуры (думаю только на мастер процессоре) - активируют
ожидающие задачи.

Системные вызовы - останавливают задачу, сохраняют параметры вызова и передают
управление дальше.

Прерывание таймера и вызов по передаче управления - просто активируют следующую
задачу. До тех пор пока список не пуст. Если список заканчивается - управление
передается тяжелому планировщику. Хотя тяжелый планировщик может стоять
последней задачей в списке (наверное это менее удобно).


Заключение.

С одной стороны многозадачное ядро будет проигрывать от частых скачков из
приложенй в ядро и обратно, но легкое ядро какраз и служит для того, чтобы
этого избежать. В идеальном варианте тяжелое ядро будет вызываться лишь
несколько раз в секунду (10-15), что не кажется очень большим числом.

В то время как легкое ядро, вызываемое более 1000 раз в секунду - до предела
примитивно. А при увеличении длинны легкого кванта - минимизируются даже
накладные расходы на прыжки между кольцами защиты.

Отложенные системные вызовы - могли бы показаться очень узким местом. Это так и
есть, но для общения приложений между собой можно использовать шареные ресурсы,
которые вообще никаких накладных расходов не принесут.

Чтобы приложения не ждали вызовов слишком долго - можно будет предусмотреть
максимальный таймаут по обработке системных вызовов. То есть Легкое ядро не
смотря на размер оставшейся очереди всеравно вызовет тяжелое ядро, которое
обработает системные вызовы.

Но вообще в данной схеме системными вызовами не стоит злоупотреблять...
Вероятно вызовы стоит усложнить. То есть тяжелое ядро будет производить много
работы на один вызов, но это уменьшит количество вызовов.

Правда, применительно к MDF Именно эту часть и не хотелось бы ломать.
Но ничего не мешает сделать старое API и новое. :)

А вообще это пока только идея. стоит обдумать.