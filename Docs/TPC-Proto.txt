
	TPC протоколы.

TODO: Существующий ныне двухбуфферый протокол будет заменен более простым однобуфферным.


	Термины TPC

Приложение, осуществляющее вызов - называется клиент.
Приложение, обрабатывающее вызов - называется сервер.
Содержимое буфера передаваемое серверу - называется запрос (request).
Содержимое буфера, возвращаемое клиенту - называется ответ (reply).


	Основа TPC.

Клиент создает буфер запроса-ответа необходимого размера, после чего осуществляет вызов. При вызове клиент может ограничить доступ к буферу. Например только чтением, или запретить маппинг (по умолчанию будет именно маппинг как наиболее оптимальный).

Сервер обязан согласовывать свои действия с опциями буфера. К примеру не должен пытаться писать в буфер, доступный только для чтения. Иначе сервер будет безжалостно убит.

Все дальнейшее взаимодействие ложиться целиком на плечи клиента-сервера, и ядру глубоко пофиг.




	Протоколы TPC


	Протокол вызова процессов.

Первая нить в процессе создается путем вызова ресурса процесса. При этом в процесс можно много чего передать. К примеру аргументы приложения, переменные окружения, возможно адреса связанных ресурсов, которые приложение может заюзать. При возврате из приложения буфер может быть использован для возврата кода ошибки.

Но пока это будет выглядеть так:

+0 DWORD reply: error optional;


	Протокол Namer

Namer - это клучевое звено в MDF. Многие сервисы работают через Namer, хотя в принципе ничего не мешает вызывать их на прямую... но тем не менее они будут пользоваться расширениями Namer-протокола.

Не смотря на то, что размер буфера задается на уровне TPC, для осуществления пробрасывания запросов может потребоваться изменение(урезание) запроса без изменения геометрии буфера.

+0 DWORD request: offset required;
	 reply: error optional;
+4 DWORD request: size required;
+8 ARRAY request: srevice optional;

Клиент обязан корректно проинициализировать поля offset (по умолчанию 8) и size (размер массива).

Поскольку сервера должны сами заботится о своей безопасности (Хотя в принципе нет ничего страшного в том, если нить обработчика умрет по кривости запроса, но это может быть небезопасно и просто некрасиво), они тщательным образом следят за корректностью запросов.

Если size  в теле запроса превышает размер TPC буфера - он должен быть обрезан.
Если offset выходит за пределы TPC буфера - он урезается соответственно.
Если буфер TPC передается с ограничением по записи - ни о каком реплае не может быть и речи. Правда меня мучает вопрос, как клиент-идиот узнает об этом, ведь Namer не сможет передать ему код ошибки.

Namer из таблицы сервисов выбирает наиболее совпадающее с массивом имя. Оставшаяся часть массива передается очередному серверу без изменений.

При обработке запроса Namer изменяет значение полей offset, size с целью предоставить очередному серверу только его часть запроса. Если сервера (Namer в том числе) страдают паранойей, они могут даже зачистить свои части запросов, дабы очередные сервера не могли получить эту информацию. По большому счеты запрос может быть переделан на 100 процентов... никаких ограничений кроме размера буфера TPC для этого нету.

Причем поля offset и size никак не влияют на позицию реплая. Клиент не должен подозревать о глубине иерархии.

Подключаемые к Namer сервера расширяют протокол намера по своему усмотрению.
Причем не исключаются ситуации, когда Namer оперирует строками (по любому Namer ориентируется на длину, то что это строка - знаем только мы с вами), а подчиненный сервер принимает чисто бинарные данные в виде структуры. никаких ограничений для этого протокол Namer так же не накладывает.


Новый протокол

Но жестко закодированные протоколы - плохо...
Идея гибридного кодирования заключается в следующем.

Строки являются основным средством передачи информации, но они не должны мешать
кодировать любую информацию. И utf8 может это позволить.

В utf8 есть один код, с которого не начинается не один символ. Этот код 0b10??????.
Это позволит легко отделить строки от дополнительной информации.
6 бит могут быть использованы для определения типа информации. А собственно типы
информаци могут быть следующими... [u]int(8|16|32) - (6 типов). oid - Для
идентификации пользовательских структур. Потом необходим еще set. set - Это
некий набор значений, сгруппированый в один элемент (с указанием количества значений).
И еще необходим pad - это резервирование места. и eof для обозначения конца потока.

например возможны следующие варианты вызовов:
'printf'
set {
	'%s: %u'
	'identifier'
	int8 { 10 }
}

То есть серверу не составит проблем разобрать запрос и разложить все по полочкам.
К тому же такая фрагментация запросов может позволить перенести интернационализацию в одно центральное место (или в несколько центральных мест). И иметь всего одну базу интернационализации.

при форварде вызовов промежуточный сервер не имеет права менять геометрию буфера,
И pad поможет ему исключить из запроса лишние данные.

'vfs://home/file.txt' -> VFS

pad (5)
'/home/file.txt'	-> ROOT

pad (10)
'/file.txt'	-> FS

Подробнее протокол я документирую позже.
Это все чем-то напоминает ASN1 кодирование.
Естественно строки должны заканчиваться нулем.


(c) 2006-2007 Андрей Валяев (dron@infosec.ru)
